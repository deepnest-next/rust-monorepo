/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/** Point */
export interface Point {
  x: number
  y: number
}
export declare function rotatePoint(point: Point, angle: number): Point
/** Polygon */
export interface Polygon {
  points: Array<Point>
  children?: Array<Array<Point>>
  offsetx?: number
  offsety?: number
}
export declare function polygonArea(polygon: Polygon): number
/** Rect used for polygon bounds */
export interface Rect {
  x: number
  y: number
  width: number
  height: number
}
/** Vector */
export interface Vector {
  x: number
  y: number
}
export const DEFAULT_TOLERANCE: number
export const DEFAULT_CURVE_TOLERANCE: number
export declare class Arc {
  /**
   * Approximates (linearizes) an elliptical arc into a polyline (a vector of points).
   *
   * # Parameters
   * - `p1`: start point (from the SVG arc definition).
   * - `p2`: end point.
   * - `rx`, `ry`: radii.
   * - `angle`: x‑axis rotation (in degrees).
   * - `largearc`: large‑arc flag.
   * - `sweep`: sweep flag.
   * - `tol`: tolerance for flatness.
   *
   * # Returns
   * A vector of points approximating the arc.
   */
  static linearize(p1: Point, p2: Point, rx: number, ry: number, angle: number, largearc: boolean, sweep: boolean, tol: number): Array<Point>
}
export declare class CubicBezier {
  /**
   * Approximates (linearizes) a cubic Bézier curve by subdividing until each segment is flat enough.
   *
   * The function returns a vector of points along the curve. The initial point `p1` is included,
   * and each flat segment’s end point is appended.
   */
  static linearize(p1: Point, p2: Point, c1: Point, c2: Point, tolerance?: number | undefined | null): Array<Point>
}
export declare class GeometryUtils {
  /**
   * Returns `true` if `a` and `b` are approximately equal within the given tolerance.
   * If `tolerance` is `None`, a default tolerance of `1e-9` is used.
   */
  static almostEqual(a: number, b: number, tolerance?: number | undefined | null): boolean
  /** Calculate the area */
  static polygonArea(polygon: Array<Point>): number
  /** get the polygon bounds */
  static getPolygonBounds(polygon: Array<Point>): Rect | null
  /** is p1 and p2 within distance */
  static withinDistance(p1: Point, p2: Point, distance: number): boolean
  /**
   * Computes the intersection of line AB with line EF.
   *
   * The lines are given in point–slope form as follows:
   * - Line 1 passes through points A and B.
   * - Line 2 passes through points E and F.
   *
   * If `infinite` is `true`, the lines are treated as infinite lines. If `false`,
   * the intersection must lie within both finite segments (within tolerance).
   *
   * Returns `Some(Point)` if a valid intersection exists, or `None` if:
   * - The lines are parallel or nearly parallel,
   * - The computed intersection is not finite, or
   * - For finite segments, the intersection lies outside at least one segment.
   */
  static lineIntersect(a: Point, b: Point, e: Point, f: Point, infinite?: boolean | undefined | null): Point | null
  /**
   * Returns true if the Euclidean distance between points `a` and `b` is less than the given tolerance.
   *
   * If `tolerance` is `None`, the default tolerance `DEFAULT_TOLERANCE` is used.
   */
  static almostEqualPoints(a: Point, b: Point, tolerance?: number | undefined | null): boolean
  /**
   * Determines if `point` lies inside the given `polygon`.
   *
   * Returns:
   * - `Some(true)` if `point` is strictly inside the polygon,
   * - `Some(false)` if `point` is strictly outside,
   * - `None` if `point` lies exactly on a vertex or on an edge (within `tolerance`).
   */
  static pointInPolygon(point: Point, polygon: Polygon, tolerance?: number | undefined | null): boolean | null
  /**
   * Returns true if the edges of polygon A and polygon B intersect.
   * The function tests every segment of A (with its optional offset) against every segment of B.
   */
  static intersect(a: Polygon, b: Polygon): boolean
  /**
   * Returns true if every vertex of the polygon lies (within tolerance) on either
   * the left/right or the top/bottom bounds of its bounding box.
   * If the polygon has fewer than 3 points, it returns false.
   */
  static isRectangle(poly: Polygon, tolerance?: number | undefined | null): boolean
  /**
   * Returns an interior No-Fit Polygon (NFP) for the special case where A is a rectangle.
   *
   * Given two polygons A and B (each as a slice of `Point`), the function computes their
   * bounding boxes. If B’s bounding box is larger than A’s in either dimension, then B cannot
   * fit, and the function returns `None`. Otherwise, it returns a single polygon (wrapped in a
   * vector) whose vertices are computed by aligning the bounding boxes appropriately.
   *
   * # Arguments
   *
   * * `a` - A slice of `Point` representing polygon A (assumed to be a rectangle).
   * * `b` - A slice of `Point` representing polygon B.
   *
   * # Returns
   *
   * * `Some(Vec<Vec<Point>>)` containing one polygon (a vector of 4 points) if an interior NFP exists.
   * * `None` if B does not fit within A.
   *
   * # Example
   *
   * ```
   * // # #[derive(Debug, Clone, Copy, PartialEq)]
   * // # pub struct Point { pub x: f64, pub y: f64 }
   * // # fn no_fit_polygon_rectangle(a: &[Point], b: &[Point]) -> Option<Vec<Vec<Point>>> { \/* ... *\/ }
   * //
   * // let rect_a = [
   * //     Point { x: 0.0, y: 0.0 },
   * //     Point { x: 10.0, y: 0.0 },
   * //     Point { x: 10.0, y: 5.0 },
   * //     Point { x: 0.0, y: 5.0 },
   * // ];
   * //
   * // let poly_b = [
   * //     Point { x: 2.0, y: 1.0 },
   * //     Point { x: 4.0, y: 1.0 },
   * //     Point { x: 4.0, y: 3.0 },
   * //     Point { x: 2.0, y: 3.0 },
   * // ];
   * //
   * // if let Some(nfp) = no_fit_polygon_rectangle(&rect_a, &poly_b) {
   * //     println!("Interior NFP: {:?}", nfp);
   * // } else {
   * //     println!("No valid NFP; polygon B is too large.");
   * // }
   * ```
   */
  static noFitPolygonRectangle(a: Array<Point>, b: Array<Point>): Array<Array<Point>> | null
  /**
   * Given two polygons A and B (which touch at at least one point but do not intersect)
   * with the same winding direction, this function returns the outer perimeter (hull)
   * of both polygons as a single continuous polygon.
   * If the polygons are not touching (or inputs are invalid) the function returns None.
   *
   * The algorithm:
   * 1. Find an extreme point (lowest y after applying offsets) among both A and B.
   * 2. Ensure the starting polygon is assigned to A (swap if necessary).
   * 3. “Scan forward” from the start point along A until a touching vertex or edge is found on B.
   * 4. “Scan backward” from the start point along A to find a second touching point on B.
   * 5. Append the points from B that lie between these two intercepts.
   * 6. Deduplicate consecutive vertices and return the result.
   */
  static polygonHull(a: Polygon, b: Polygon): Array<Point> | null
}
export declare class QuadraticBezier {
  /**
   * Converts (linearizes) a quadratic Bézier curve into a sequence of points
   * by repeatedly subdividing the curve until each segment is flat enough
   * according to the provided tolerance.
   *
   * The returned vector contains the starting point and the end point of each
   * flat segment, in order along the curve.
   */
  static linearize(p1: Point, p2: Point, c1: Point, tolerance?: number | undefined | null): Array<Point>
}
/**
 * A helper struct representing a quadratic Bézier segment defined by
 * endpoints `p1` and `p2` and a single control point `c1`.
 */
export declare class BezierSegment {
  p1: Point
  p2: Point
  c1: Point
}
