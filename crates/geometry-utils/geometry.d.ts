/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export const DEFAULT_TOLERANCE: number
export const DEFAULT_CURVE_TOLERANCE: number
export declare class Arc {
  /**
   * Approximates (linearizes) an elliptical arc into a polyline (a vector of points).
   *
   * # Parameters
   * - `p1`: start point (from the SVG arc definition).
   * - `p2`: end point.
   * - `rx`, `ry`: radii.
   * - `angle`: x‑axis rotation (in degrees).
   * - `largearc`: large‑arc flag.
   * - `sweep`: sweep flag.
   * - `tol`: tolerance for flatness.
   *
   * # Returns
   * A vector of points approximating the arc.
   */
  static linearize(p1: Point, p2: Point, rx: number, ry: number, angle: number, largearc: boolean, sweep: boolean, tol: number): Array<Point>
}
export declare class CubicBezier {
  /**
   * Approximates (linearizes) a cubic Bézier curve by subdividing until each segment is flat enough.
   *
   * The function returns a vector of points along the curve. The initial point `p1` is included,
   * and each flat segment’s end point is appended.
   */
  static linearize(p1: Point, p2: Point, c1: Point, c2: Point, tolerance?: number | undefined | null): Array<Point>
}
export declare class GeometryUtils {
  /**
   * Returns `true` if `a` and `b` are approximately equal within the given tolerance.
   * If `tolerance` is `None`, a default tolerance of `1e-9` is used.
   */
  static almostEqual(a: number, b: number, tolerance?: number | undefined | null): boolean
  /** Calculate the area */
  static polygonArea(polygon: Array<Point>): number
  /** get the polygon bounds */
  static getPolygonBounds(polygon: Array<Point>): Rect | null
  /** is p1 and p2 within distance */
  static withinDistance(p1: Point, p2: Point, distance: number): boolean
  /**
   * Computes the intersection of line AB with line EF.
   *
   * The lines are given in point–slope form as follows:
   * - Line 1 passes through points A and B.
   * - Line 2 passes through points E and F.
   *
   * If `infinite` is `true`, the lines are treated as infinite lines. If `false`,
   * the intersection must lie within both finite segments (within tolerance).
   *
   * Returns `Some(Point)` if a valid intersection exists, or `None` if:
   * - The lines are parallel or nearly parallel,
   * - The computed intersection is not finite, or
   * - For finite segments, the intersection lies outside at least one segment.
   */
  static lineIntersect(a: Point, b: Point, e: Point, f: Point, infinite: boolean): Point | null
  /**
   * Returns true if the Euclidean distance between points `a` and `b` is less than the given tolerance.
   *
   * If `tolerance` is `None`, the default tolerance `DEFAULT_TOLERANCE` is used.
   */
  static almostEqualPoints(a: Point, b: Point, tolerance?: number | undefined | null): boolean
}
export declare class QuadraticBezier {
  /**
   * Converts (linearizes) a quadratic Bézier curve into a sequence of points
   * by repeatedly subdividing the curve until each segment is flat enough
   * according to the provided tolerance.
   *
   * The returned vector contains the starting point and the end point of each
   * flat segment, in order along the curve.
   */
  static linearize(p1: Point, p2: Point, c1: Point, tolerance?: number | undefined | null): Array<Point>
}
/**
 * A helper struct representing a quadratic Bézier segment defined by
 * endpoints `p1` and `p2` and a single control point `c1`.
 */
export declare class BezierSegment {
  p1: Point
  p2: Point
  c1: Point
}
export declare namespace Point {
  /** Point */
  export interface Point {
    x: number
    y: number
  }
  export function rotatePoint(point: Point, angle: number): Point
}
export declare namespace Polygon {
  /** Point */
  export interface Polygon {
    points: Array<Point>
    children?: Array<Array<Point>>
  }
  export function polygonArea(polygon: Polygon): number
}
export declare namespace Rect {
  /** Rect used for polygon bounds */
  export interface Rect {
    x: number
    y: number
    width: number
    height: number
  }
}
export declare namespace Vector {
  /** Vector */
  export interface Vector {
    x: number
    y: number
  }
}
